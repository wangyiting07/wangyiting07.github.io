<!DOCTYPE html>
<html lang="en">
  <head>
    <title>Yiting Wang</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
<<<<<<< HEAD
    <style>
      body{
        font-family: Arial, Helvetica, sans=sans-serif;
      }
      /*Style the header*/
      .header{
        padding: 200px;
        text-align: center;
        background-color: #000000;
<<<<<<< HEAD
        background-image: url(images/pets.JPG);
=======
        background-image: url(images/desktop.jpg);
>>>>>>> Changed some style. Focus on content first.
        background-repeat:no-repeat;
        background-size: cover;
        color: #000000;
      }
      /* Increase the font size of the h1 element */
      .header h1 {
          font-size: 40px;
      }
      /* Style the top navigation bar */
      .navbar {
          overflow: hidden;
          background-color: #333;
          position: fixed;
          top:0;
          width: 100%;
      }
      /* Style the navigation bar links */
      .navbar a {
          float: left;
          display: block;
          color: white;
          text-align: center;
          padding: 14px 20px;
          text-decoration: none;
      }

      /* Right-aligned link */
      .navbar a.right {
          float: right;
      }

      /* Change color on hover */
      .navbar a:hover {
          background-color: #ddd;
          color: black;
      }
      /* Column container */
      .row {  
          /*clear: both;*/
          display: inline-flex;
          /*flex-wrap: wrap;*/
          width: 100%;
      }

      /* Create two unequal columns that sits next to each other */
      /* Sidebar/left column */
      .side {
          flex: 30%;
          background-color: #f1f1f1;
          padding: 10px;
          color:lightcoral
      }

      /* Main column */
      .main {   
          flex: 70%;
          background-color: white;
          padding: 20px;
          color:#000000;
      }

      /* Fake image, just for this example */
      .fakeimg {
          background-color: #aaa;
          width: 100%;
          padding: 20px;
      }
      /*class for the first line indent*/
      .indent {
        padding-left: 1.8em
      }
    </style>
=======
    <link rel="stylesheet" href="myStyles.css">
>>>>>>> rearrange the structure of this project
  </head>

  <body>
    <div class="header">
      <h1>My Place</h1>
      <p>A place to record the life.</p>
    </div>
    <!-- <img src="images/pets.jpg" alt="My test image"> -->
    <div class="navbar">
      <a href="https://wangyiting07.github.io/CSAPP/">Major</a>
      <a href="">Language</a>
      <a href="">Hobby</a>
      <a href="">Travels</a>
      <a href="https://wangyiting07.github.io" class="right">Home</a>
    </div>

    <div class="row">
      <div class="side">
          <h2>About Me</h2>
          <h5>Photo of me:</h5>
          <p>Some text about me in culpa qui officia deserunt mollit anim..</p>
          <!-- <h3>More Text</h3>
          <p>Lorem ipsum dolor sit ame.</p>
          <div class="fakeimg" style="height:60px;">Image</div><br>
          <div class="fakeimg" style="height:60px;">Image</div><br>
          <div class="fakeimg" style="height:60px;">Image</div> -->
      </div>
      <div class="main">
<<<<<<< HEAD
          <h1>Cloud</h1>

          <h2>Key Concepts</h2>

          <h3>Container</h3>
          <p>Extend link <a href="URL">https://slideplayer.com/slide/12137884/</a>
          </p>

          <h3>Microservices</h3>
          <p>Details see <a href="URL">https://martinfowler.com/articles/microservices.html</a>
          </p>

          <h3>Scaling</h3>
          <h4>Notes from the reference</h4>
          <p>
            <b>1. Single Server</b><br>
            <ul>
              <li>Since nodejs by nature uses an event-driven and non-blocking I/O model, it will not block with a single request.
                It can take multiple requests while waiting for the database or file system to respond.</li>
              <li>The app should be a monolith (single app). The downside of this is if you make changes, you will need to take it down the app while 
                  updating the server.</li>
              <li>Web application and database share the same resources (CPU, Memory RAM, I/O).</li>
              <li>Using AWS t2.micro/t2.nano or equivalent (1 CPU/1 GB RAM)</li>
            </ul>

            <b>2. Vertical Scaling 10~99 users</b><br>
            <ul>
              <li>Upgrading a single server hardware with more resources such as higher/faster CPU, RAM, HDD and I/O</li>
              <li>Since we have multi CPU cores, we can run two instances of nodejs and load balance it. In this way, there is no downtime for updating server. Take one server down to 
                update another one, vice versus. <font color="red">Do we just have one server here?</font>
              </li>
              <li>Advantage: (1) Zero-downtime upgrades. (2) <font color="red">Reverse Proxy ????</font>Reverse Proxy ???? Nginx takes care of users requests and accomplish two functions: static filers server and reverse proxy. It serve by itself all static files (CSS, JS, Images) without touching the web app. The request that needs the app to resolve are redirected it </li>
              <li>AWS upgrade to t2.medium or equivalent (2 CPU / 4 GB RAM).</li>
            </ul>

            <b>3. Horizontal Scaling 100 - 999 users</b><br>
            <ul>
              <li>The bottleneck here may be the I/O(vertical) and database(horizontal). And the larger vertical scaling gets really expensive. </li>
              <li>Horizontal scaling will give you redundancy and failover capabilities if done right.</li>
              <li>Move the database to a different server and scale it independently</li>
              <li>Add replica set if the database hits its limit and db caching if it makes sense</li>
              <li>Solve network limits: You might need to play also with /etc/security/limits.d and /etc/sysctl.conf based on your needs.</li>
            </ul>

            <b>4. Multi-servers 1000+ users</b><br>
            <ul>
              <li>Add load balancer (e.g. ELB) and add app units.</li>
              <li>Use multiple availability zones (AZ) in a region (e.g. us-east-1, us-west-1), which one are connected through low latency links.</li>
              <li>Split static files to different server/service for easier maintenance. (e.g. AWS S3 and CloudFront CDN). Add CDN for static files for optimizing cross-origin performance and lower the latency. You can store assets such as Javascript, CSS, images, videos, and so on.</li>
              <li>In this server setup, we started growing horizontally rather than vertically. In other words, we separated web application from database and scale each one with multiple instances. </li>

            </ul>

            <b>5. Microservices</b><br>
            <ul>
              <li>Break our application down to into multiple smaller and independent components, so that we can scale independently. </li>
            </ul>
            <b>6. Automate Chores (1,000,000+ concurrent users)</b><br>
          </p>
          <p>Reference study link:<a href="URL">https://adrianmejia.com/blog/2016/03/23/how-to-scale-a-nodejs-app-based-on-number-of-users/</a><br>
             Learn Node.js here: <a href="URL">https://nodejs.org/en/about/</a>
          </p>

          <h3>Container Orchestration</h3>

          <h3>Multi Tenancy</h3>
          <p>link for study: <a href="URL">http://multitenancy-in-saas-paas.wikispaces.asu.edu/</a><br>
            <a href="URL">https://www.altexsoft.com/blog/business/starting-a-saas-business-9-steps-towards-success/</a>
          </p>
=======
          <h2>Machine Learning</h2>
          <h5>Title description, Dec 7, 2017</h5>
          <p>Some text..</p>
          <p>1. Regularizer control the complexity</p>
         
>>>>>>> Changed some style. Focus on content first.
      </div>
    </div>

  </body>
</html>
